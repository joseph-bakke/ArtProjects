/*
 * Project Title: Vocab Evolution
 * Name: Joseph Bakke
 * Date: 6/5/2014
 * Description:
 * For the purpose of analyzing a data set I thought it would be interesting to look at how my vocabulary has changed over my lifetime.
 * In order to do so I downloaded my entire facebook chat history, parsed out all of the words, then counted how often I used each word per year.
 * You are able to scroll through the years by using the left and right arrow keys, and navigate by clicking and dragging the mouse.
 * Each circle represents one word, where the size of the circle is generated by the word count.
 * 
 * After I developed the project to its current state I realized that due to the nature of human language the words were going to be generally consistent
 * for each year. In retrospect it would have been more interesting to analyze metrics such as average word length, longest word, shortest word etc.
 * Additionally, due facebook not logging my chat entirely accurately, there is a disparity in data across the years which takes away from the visual effect.
 */

package main;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.net.URL;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Random;
import java.util.Set;

import peasy.PeasyCam;
import processing.core.PApplet;

public class Main extends PApplet {

	private HashMap<String, HashMap> years;
	
	private Integer[] maxRad;
	private Integer[] curRad;
	private Integer[] zTrans;
	private String[] labels;
	private String[] yearArray;
	private int scale;
	private int max;
	
	private int yearIndex;
	
	private String currYear;
	private String newYear;
	
	private PeasyCam cam;
	
	public static void main( String[] args ) {
		PApplet.main(new String[] { "--present", "main.Main" });
	}
	
	public void setup() {
		this.size(1024,768, P3D);
		this.background(255);
		this.frameRate(30);
		this.smooth();
		
		currYear = "";
		newYear = "2010";
		scale = 3;
		yearIndex = 3;
		cam = new PeasyCam(this, 2700);
		cam.lookAt(width/2, height/2, 0);
		cam.setYawRotationMode();	
		
		this.getData();
		
		Set<String> y = years.keySet();
		yearArray = new String[y.size()];
		yearArray = y.toArray(yearArray);
		Arrays.sort(yearArray);
	}
	
	public void draw() {
		background(0);
		frameRate(60);
		smooth();
		
		/* Rebuild the sets only if a new year is selected*/
		if( currYear.compareTo(newYear) != 0 ) {
			Object[] v = this.years.get(newYear).values().toArray();
			Set<String> keys = years.get(newYear).keySet();
			labels = new String[keys.size()];
			labels = keys.toArray(labels);
			
			maxRad = new Integer[v.length];
			curRad = new Integer[v.length];
			zTrans = new Integer[v.length];
			
			for( int i = 0 ; i < v.length ; i++ ) {
				maxRad[i] = (int) ((int)v[i]*scale + Math.random()*50);
				curRad[i] = 0;
			}

			setMax();
			buildTranslate();
		
			currYear = newYear;
		}

		//Draw the circles and the labels
		drawCircles();
		
		//Draw the year name
		pushMatrix();
			translate(width/2, height/2, 0);
			textSize(128);
			fill(169,160,255,150);
			stroke(4);
			
			//Rotate the text so it's always facing the camera
			pushMatrix();
				translate(0, -max/2-textWidth(currYear), 0);
				float[] rotations = cam.getRotations();
				rotateX(rotations[0]);
				rotateY(rotations[1]);
				rotateZ(rotations[2]);
				text(currYear, 0, 0);
			popMatrix();
		popMatrix();
		
		//Draw the selection buttons
	}
	
	public void keyPressed() {
		if( key == CODED ) {
			if( keyCode == LEFT ) {
				yearIndex--;
				if( yearIndex < 0 ) {
					yearIndex = yearArray.length-1;
				}
			} else if( keyCode == RIGHT ) {
				yearIndex++;
				if( yearIndex == yearArray.length) {
					yearIndex = 0;
				}
			}
			
			this.newYear = yearArray[yearIndex];
		}
	}
	
	public void drawCircles() {
		for( int i = 0 ; i < curRad.length ; i++ ) {
			if( curRad[i] < maxRad[i] ) {
				curRad[i]+=maxRad[i]/35;
			}
		}
		
		for( int i = 0 ; i < curRad.length ; i++ ) {
			//Move the circles into the correct x, y, z position
			pushMatrix();
				translate(width/2, height/2, zTrans[i]);
				fill(169,160,255,60);
				stroke(1);
				ellipse(0, 0, curRad[i], curRad[i]);
				
				//draw the label correlating to the circle being drawn
				drawLabel(curRad[i], i);
			popMatrix();
		}
	}
	
	public void drawLabel(int curRad, int index) {
		String label = labels[index];
	
		float rot = (float) (index*5);

		//First rotate the lines and the text around the current point of focus (width/2, height/2)
		pushMatrix();
			rotateZ(radians(rot));
			stroke(55);
			line( curRad/2+10, 0, max/2+5, 0);
			
			//Shift the point of focus to the center of the text, then rotate around the center of the text so the text is always facing the camera
			pushMatrix();
				textSize(45);
				fill(255);
				translate(max/2+30, 0, 0);
				rotateZ(radians(-rot));
				float[] rotations = cam.getRotations();
				rotateX(rotations[0]);
				rotateY(rotations[1]);
				rotateZ(rotations[2]);
				text(label, 0, 0, 0);
			popMatrix();
		popMatrix();
	}
	
	/**
	 * Randomly generate the z transformation for drawing the circles
	 */
	public void buildTranslate() {
		Random rand = new Random();
		
		for( int i = 0 ; i < zTrans.length ; i++ ) {
			zTrans[i] = rand.nextInt((1500 - 10) + 1) + 10;
			zTrans[i] = rand.nextBoolean() == true ? zTrans[i] : zTrans[i]*(-1);
			
			if( maxRad[i] == max ) {
				zTrans[i] = 0;
			}
		}
	}
	
	/**
	 * Get the max value in the current year's dataset
	 */
	public void setMax() {
		this.max = 0;
		
		for( int curr : maxRad ) {
			max = curr > max ? curr : max;
		}
	}
	
	/**
	 * Builds the initial data from the files provided
	 */
	public void getData() {
		
		final File folder = new File("src/data/");
		
		this.years = new HashMap<String, HashMap>();
		
		for( File fileEntry : folder.listFiles() ) {
			String fileYear = fileEntry.getName().substring(0, 4);	
			String line = null;
			FileReader fr = null;
			HashMap<String, Integer> words = new HashMap<String, Integer>();
			
			try {
				fr = new FileReader(fileEntry.getPath());
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
			
			BufferedReader reader = new BufferedReader(fr);
		
			try {
				while((line = reader.readLine()) != null ) {
					String[] data = line.split(",");
					words.put(data[0], new Integer(data[1]));
				}
			} catch (IOException e) {
				e.printStackTrace();
			}

			this.years.put(fileYear, words);
		}
	}
	
	/**
	 * Prints data from files in human readable format for debugging purposes
	 */
	public void printData() {
		Iterator<String> it = this.years.keySet().iterator();
		
		while( it.hasNext() ) {
			String yearKey = it.next();
			
			HashMap<String, Integer> tmp = this.years.get(yearKey);
			
			Iterator<String> tmpIt = tmp.keySet().iterator();

			System.out.println(yearKey);
			while( tmpIt.hasNext() ) {
				String key = tmpIt.next();
				
				System.out.println(key + ", " + tmp.get(key));
			}
		}
	}
}
